#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const WHITELABELS_DIR = path.join(process.cwd(), 'whitelabels');
const ACTIVE_FILE = path.join(WHITELABELS_DIR, '.active');

function getActiveWhiteLabel() {
  try {
    return fs.readFileSync(ACTIVE_FILE, 'utf-8').trim() || 'default';
  } catch {
    return 'default';
  }
}

function getAvailableWhiteLabels() {
  try {
    const whiteLabels = [];
    const files = fs.readdirSync(WHITELABELS_DIR);
    
    // Check for config files in subdirectories (e.g., default/default.json, example/example.json)
    for (const file of files) {
      const filePath = path.join(WHITELABELS_DIR, file);
      const stat = fs.statSync(filePath);
      
      if (stat.isDirectory() && file !== 'lib' && file !== 'scripts') {
        const configPath = path.join(filePath, `${file}.json`);
        if (fs.existsSync(configPath)) {
          whiteLabels.push(file);
        }
      } else if (stat.isFile() && file.endsWith('.json') && file !== '.active' && file !== 'config.json') {
        // Legacy support: config files directly in whitelabels/ directory
        whiteLabels.push(file.replace('.json', ''));
      }
    }
    
    return whiteLabels.length > 0 ? whiteLabels : ['default'];
  } catch {
    return ['default'];
  }
}

function getConfigPath(name) {
  // First check in subdirectory (e.g., default/default.json)
  const subdirPath = path.join(WHITELABELS_DIR, name, `${name}.json`);
  if (fs.existsSync(subdirPath)) {
    return subdirPath;
  }
  
  // Fallback to legacy location (e.g., default.json)
  const legacyPath = path.join(WHITELABELS_DIR, `${name}.json`);
  if (fs.existsSync(legacyPath)) {
    return legacyPath;
  }
  
  return null;
}

function setActiveWhiteLabel(name) {
  const configPath = getConfigPath(name);
  
  if (!configPath) {
    console.error(`‚ùå White-label config "${name}" does not exist`);
    process.exit(1);
  }
  
  fs.writeFileSync(ACTIVE_FILE, name, 'utf-8');
  console.log(`‚úÖ Switched to white-label: ${name}`);
}

function loadWhiteLabelConfig(name) {
  const configPath = getConfigPath(name);
  
  if (!configPath) {
    throw new Error(`White-label config "${name}" does not exist`);
  }
  
  try {
    const configContent = fs.readFileSync(configPath, 'utf-8');
    return JSON.parse(configContent);
  } catch (error) {
    throw new Error(`Failed to load white-label config "${name}": ${error.message}`);
  }
}

function generateAppJson(config) {
  const icons = config.icons || {
    icon: "./assets/images/icon.png",
    splash: "./assets/images/splash-icon.png",
    adaptiveIcon: "./assets/images/adaptive-icon.png",
    favicon: "./assets/images/favicon.png"
  };

  return {
    expo: {
      name: config.name,
      slug: config.slug,
      version: config.version,
      orientation: "portrait",
      icon: icons.icon,
      scheme: config.scheme,
      userInterfaceStyle: "automatic",
      newArchEnabled: true,
      splash: {
        image: icons.splash,
        resizeMode: "contain",
        backgroundColor: config.branding.splashBackgroundColor
      },
      ios: {
        supportsTablet: true,
        bundleIdentifier: config.bundleIdentifier.ios
      },
      android: {
        adaptiveIcon: {
          foregroundImage: icons.adaptiveIcon,
          backgroundColor: config.branding.splashBackgroundColor
        },
        package: config.bundleIdentifier.android
      },
      web: {
        favicon: icons.favicon
      },
      plugins: [
        [
          "expo-router",
          {
            origin: config.routerOrigin
          }
        ],
        "expo-font",
        "expo-web-browser",
        "expo-video"
      ],
      experiments: {
        typedRoutes: true,
        reactCompiler: true
      },
      extra: {
        router: {
          origin: config.routerOrigin
        },
        eas: {
          projectId: config.easProjectId
        }
      },
      owner: config.owner
    }
  };
}

function generateColorsFile(config) {
  const lightColors = config.colors.light;
  const darkColors = config.colors.dark;
  
  return `// Auto-generated from white-label config
// Do not edit this file manually - it will be overwritten

const light = ${JSON.stringify(lightColors, null, 2)};
const dark = ${JSON.stringify(darkColors, null, 2)};

export default {
  light,
  dark,
};
`;
}

function generateInstantFile(config) {
  return `// Auto-generated from white-label config
// Do not edit this file manually - it will be overwritten

import { init, i, id } from '@instantdb/react-native';

// Get your APP_ID from https://instantdb.com/dash
const APP_ID = '${config.instantDbAppId}';

// Define the schema for InstantDB
const schema = i.schema({
  entities: {
    workouts: i.entity({
      title: i.string(),
      culturalName: i.string(),
      description: i.string(),
      duration: i.number(),
      difficulty: i.string(),
      equipment: i.json(), // Array of strings
      category: i.string(),
      caloriesBurn: i.number(),
      imageUrl: i.string(),
      createdAt: i.number(),
    }),
    exercises: i.entity({
      workoutId: i.string(),
      name: i.string(),
      reps: i.string().optional(),
      duration: i.number().optional(),
      instructions: i.json(), // Array of strings
      videoUrl: i.string().optional(),
      imageUrl: i.string().optional(),
      order: i.number(),
    }),
    nutritionTips: i.entity({
      title: i.string(),
      category: i.string(), // 'dal-bhat' | 'momo' | 'traditional' | 'modern'
      description: i.string(),
      imageUrl: i.string(),
      tips: i.json(), // Array of strings
      calories: i.number().optional(),
      protein: i.number().optional(),
      carbs: i.number().optional(),
      fat: i.number().optional(),
      createdAt: i.number(),
    }),
    // Note: $users is automatically created by InstantDB for auth
    // It contains basic info: email (main identifier), id
    // We need to reference it in the schema to use it in links
    $users: i.entity({
      email: i.string(),
    }),
    // Custom users table - contains all user information and stats
    // Linked to $users via userId (which is the $users.id)
    users: i.entity({
      userId: i.string(), // Reference to $users.id
      email: i.string(), // Duplicated from $users for easier queries
      name: i.string(),
      avatar: i.string().optional(),
      // Stats - simple numbers
      workoutStreak: i.number(),
      totalWorkouts: i.number(),
      points: i.number(),
      // Additional data
      customMetrics: i.json(), // { energyLevel, sleepQuality, lastWorkoutDate, weight }
      goals: i.json(), // Array of UserGoal
      preferences: i.json().optional(), // AchievementPreferences
      createdAt: i.number(),
      updatedAt: i.number(),
    }),
    authCodes: i.entity({
      email: i.string(),
      code: i.string(),
      expiresAt: i.number(),
      used: i.boolean(),
      createdAt: i.number(),
    }),
    workoutLogs: i.entity({
      userId: i.string(),
      workoutId: i.string(),
      date: i.string(), // ISO date string
      duration: i.number(),
      caloriesBurned: i.number(),
      energyBefore: i.number(),
      energyAfter: i.number(),
      notes: i.string().optional(),
      createdAt: i.number(),
    }),
    achievements: i.entity({
      userId: i.string(),
      achievementId: i.string(), // e.g., 'first_workout', 'week_warrior'
      title: i.string(),
      description: i.string(),
      icon: i.string(),
      unlockedDate: i.string(), // ISO date string
      createdAt: i.number(),
    }),
    socialPosts: i.entity({
      userId: i.string(),
      userName: i.string(),
      userAvatar: i.string().optional(),
      type: i.string(), // 'achievement' | 'workout' | 'milestone' | 'challenge'
      content: i.string(),
      likes: i.number(),
      likedBy: i.json().optional(), // Array of user IDs who liked this post
      comments: i.number(),
      data: i.json().optional(), // Additional post data
      createdAt: i.number(),
    }),
    comments: i.entity({
      postId: i.string(), // Reference to socialPosts.id
      userId: i.string(),
      userName: i.string(),
      userAvatar: i.string().optional(),
      content: i.string(),
      createdAt: i.number(),
    }),
    // User workout instances - tracks individual user progress through a workout
    // Multiple instances allowed per user per workout (one per day/session)
    userWorkouts: i.entity({
      userId: i.string(), // Reference to users.id
      workoutId: i.string(), // Reference to workouts.id
      status: i.string(), // 'not_started' | 'in_progress' | 'completed'
      completedExercises: i.json(), // Array of exercise IDs that are completed
      workoutDate: i.string(), // ISO date string (YYYY-MM-DD) to identify daily sessions
      startedAt: i.number().optional(), // Timestamp when workout was started
      completedAt: i.number().optional(), // Timestamp when workout was completed
      createdAt: i.number(),
      updatedAt: i.number(),
    }),
  },
  links: {
    workoutExercises: {
      forward: {
        on: 'workouts',
        has: 'many',
        label: 'exercises',
      },
      reverse: {
        on: 'exercises',
        has: 'one',
        label: 'workout',
      },
    },
    // Note: $users is read-only, so we can't create links FROM it
    // We store the reference in users.userId field pointing to $users.id
    // For querying, we query users table and use the userId field
    // Link users to workoutLogs
    userWorkoutLogs: {
      forward: {
        on: 'users',
        has: 'many',
        label: 'workoutLogs',
      },
      reverse: {
        on: 'workoutLogs',
        has: 'one',
        label: 'user',
      },
    },
    // Link users to achievements
    userAchievements: {
      forward: {
        on: 'users',
        has: 'many',
        label: 'achievements',
      },
      reverse: {
        on: 'achievements',
        has: 'one',
        label: 'user',
      },
    },
    // Link users to socialPosts
    userSocialPosts: {
      forward: {
        on: 'users',
        has: 'many',
        label: 'socialPosts',
      },
      reverse: {
        on: 'socialPosts',
        has: 'one',
        label: 'user',
      },
    },
    // Link socialPosts to comments
    postComments: {
      forward: {
        on: 'socialPosts',
        has: 'many',
        label: 'comments',
      },
      reverse: {
        on: 'comments',
        has: 'one',
        label: 'post',
      },
    },
    // Link users to comments
    userComments: {
      forward: {
        on: 'users',
        has: 'many',
        label: 'comments',
      },
      reverse: {
        on: 'comments',
        has: 'one',
        label: 'user',
      },
    },
    // Link users to userWorkouts
    userUserWorkouts: {
      forward: {
        on: 'users',
        has: 'many',
        label: 'userWorkouts',
      },
      reverse: {
        on: 'userWorkouts',
        has: 'one',
        label: 'user',
      },
    },
  },
});

// Initialize InstantDB
export const db = init({ 
  appId: APP_ID, 
  schema,
});

export { id };

export type Schema = typeof schema;
`;
}

function copyIcons(whiteLabelName, config) {
  const iconsDir = path.join(WHITELABELS_DIR, whiteLabelName, 'icons');
  const targetDir = path.join(process.cwd(), 'assets', 'images');
  
  // Ensure target directory exists
  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
  }
  
  // Check if white-label has its own icons directory
  if (!fs.existsSync(iconsDir)) {
    console.log('‚ÑπÔ∏è  No custom icons directory found, using default icons');
    return;
  }
  
  const iconFiles = ['icon.png', 'splash-icon.png', 'adaptive-icon.png', 'favicon.png'];
  let copiedCount = 0;
  
  iconFiles.forEach(file => {
    const sourcePath = path.join(iconsDir, file);
    const targetPath = path.join(targetDir, file);
    
    if (fs.existsSync(sourcePath)) {
      fs.copyFileSync(sourcePath, targetPath);
      copiedCount++;
    }
  });
  
  if (copiedCount > 0) {
    console.log(`‚úÖ Copied ${copiedCount} icon file(s) from white-label icons directory`);
  }
}

function applyWhiteLabel(name) {
  console.log(`\nüîÑ Applying white-label: ${name}`);
  
  const config = loadWhiteLabelConfig(name);
  
  // Copy icons from white-label directory if they exist
  copyIcons(name, config);
  
  // Generate app.json
  const appJson = generateAppJson(config);
  fs.writeFileSync(
    path.join(process.cwd(), 'app.json'),
    JSON.stringify(appJson, null, 2) + '\n',
    'utf-8'
  );
  console.log('‚úÖ Generated app.json');
  
  // Generate constants/colors.ts
  const colorsContent = generateColorsFile(config);
  fs.writeFileSync(
    path.join(process.cwd(), 'constants', 'colors.ts'),
    colorsContent,
    'utf-8'
  );
  console.log('‚úÖ Generated constants/colors.ts');
  
  // Generate lib/instant.ts
  const instantContent = generateInstantFile(config);
  fs.writeFileSync(
    path.join(process.cwd(), 'lib', 'instant.ts'),
    instantContent,
    'utf-8'
  );
  console.log('‚úÖ Generated lib/instant.ts');
  
  // Generate whitelabel-config.json for runtime access
  fs.writeFileSync(
    path.join(process.cwd(), 'whitelabels', 'config.json'),
    JSON.stringify(config, null, 2) + '\n',
    'utf-8'
  );
  console.log('‚úÖ Generated whitelabels/config.json');
  
  // Set active white-label
  setActiveWhiteLabel(name);
  
  console.log(`\n‚ú® White-label "${name}" applied successfully!`);
  console.log('üí° You may need to restart your development server for changes to take effect.\n');
}

// Main CLI logic
const args = process.argv.slice(2);
const command = args[0];

if (!command || command === '--help' || command === '-h') {
  console.log(`
White-label Management Script

Usage:
  node whitelabels/scripts/switch-whitelabel.js <command> [options]

Commands:
  switch <name>     Switch to a white-label configuration
  list              List all available white-labels
  current           Show the currently active white-label
  apply <name>      Apply a white-label (generates files)

Examples:
  node whitelabels/scripts/switch-whitelabel.js switch default
  node whitelabels/scripts/switch-whitelabel.js list
  node whitelabels/scripts/switch-whitelabel.js current
  node whitelabels/scripts/switch-whitelabel.js apply default
`);
  process.exit(0);
}

try {
  switch (command) {
    case 'switch':
    case 'apply': {
      const name = args[1];
      if (!name) {
        console.error('‚ùå Please provide a white-label name');
        console.log('Available white-labels:', getAvailableWhiteLabels().join(', '));
        process.exit(1);
      }
      applyWhiteLabel(name);
      break;
    }
    
    case 'list': {
      const available = getAvailableWhiteLabels();
      const active = getActiveWhiteLabel();
      console.log('\nAvailable white-labels:');
      available.forEach(name => {
        const marker = name === active ? '‚úì (active)' : ' ';
        console.log(`  ${marker} ${name}`);
      });
      console.log();
      break;
    }
    
    case 'current': {
      const active = getActiveWhiteLabel();
      const config = loadWhiteLabelConfig(active);
      console.log(`\nCurrent white-label: ${active}`);
      console.log(`  Name: ${config.name}`);
      console.log(`  Slug: ${config.slug}`);
      console.log(`  Scheme: ${config.scheme}`);
      console.log();
      break;
    }
    
    default:
      console.error(`‚ùå Unknown command: ${command}`);
      console.log('Run with --help to see available commands');
      process.exit(1);
  }
} catch (error) {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
}

